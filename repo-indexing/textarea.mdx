# Textarea Components

## Overview

### Purpose

Use this component to generate textarea functionality

### When to Use

The Textarea component is a multi-line text input element that should be used when you need to collect longer form input from users. Use textareas when you need to:

- Collect multi-line text input like comments, descriptions, or messages
- Allow users to write longer content that spans multiple lines
- Provide a resizable input area for user content
- Implement form fields that require more space than standard input fields
- Create accessible text areas with consistent styling across the application
- Handle text input that may contain line breaks or formatted content
- Build forms with rich text input requirements

### Architecture

**No Coupling**: The Textarea component is a standalone component that can be used independently without requiring other components. It provides a consistent interface for multi-line text input across the application with built-in styling and accessibility features.

## Components

### Textarea {Standalone Component}

A styled multi-line text input element with consistent appearance and accessibility features.

**Purpose:** Creates accessible, styled textarea elements with consistent behavior and appearance across the application. Built on top of the native HTML textarea element with enhanced styling and accessibility features.

**Interface:**

```typescript
interface TextareaProps extends React.ComponentProps<"textarea"> {
  className?: string;
  // Inherits all standard textarea HTML attributes:
  // value?: string;
  // onChange?: (event: React.ChangeEvent<HTMLTextAreaElement>) => void;
  // placeholder?: string;
  // rows?: number;
  // cols?: number;
  // disabled?: boolean;
  // required?: boolean;
  // readOnly?: boolean;
  // maxLength?: number;
  // minLength?: number;
  // name?: string;
  // id?: string;
  // autoFocus?: boolean;
  // wrap?: "hard" | "soft" | "off";
  // resize?: "none" | "both" | "horizontal" | "vertical";
}
```

**Usage Example:**

```tsx
import { Textarea } from "@/components/ui/textarea";

function BasicExample() {
  return (
    <Textarea
      placeholder="Enter your message here..."
      onChange={(e) => console.log(e.target.value)}
    />
  );
}
```

## Integration Patterns

### Basic Usage

```tsx
import { Textarea } from "@/components/ui/textarea";

// Standard textarea usage
function BasicTextarea() {
  return (
    <div className="space-y-2">
      <label htmlFor="message">Message</label>
      <Textarea id="message" placeholder="Type your message here..." rows={4} />
    </div>
  );
}
```

### Advanced Usage

```tsx
import { Textarea } from "@/components/ui/textarea";
import { useState } from "react";

// Advanced textarea usage with state management and validation
function AdvancedTextarea() {
  const [value, setValue] = useState("");
  const [error, setError] = useState("");

  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setValue(e.target.value);
    if (e.target.value.length > 500) {
      setError("Message must be 500 characters or less");
    } else {
      setError("");
    }
  };

  return (
    <div className="space-y-2">
      <label htmlFor="description">Description</label>
      <Textarea
        id="description"
        value={value}
        onChange={handleChange}
        placeholder="Enter a detailed description..."
        rows={6}
        maxLength={500}
        className={error ? "border-destructive" : ""}
      />
      <div className="flex justify-between text-sm text-muted-foreground">
        <span>
          {error && <span className="text-destructive">{error}</span>}
        </span>
        <span>{value.length}/500</span>
      </div>
    </div>
  );
}
```

### Common Variations

```tsx
import { Textarea } from "@/components/ui/textarea";

// Different textarea configurations
function TextareaVariations() {
  return (
    <div className="space-y-6">
      {/* Compact textarea */}
      <Textarea
        placeholder="Short message..."
        rows={2}
        className="resize-none"
      />

      {/* Large textarea with custom styling */}
      <Textarea
        placeholder="Long form content..."
        rows={8}
        className="min-h-32 font-mono text-sm"
      />

      {/* Disabled textarea */}
      <Textarea
        placeholder="This field is disabled"
        disabled
        value="Read-only content"
      />

      {/* Required textarea with custom validation */}
      <Textarea
        placeholder="Required field..."
        required
        aria-describedby="field-error"
        className="aria-invalid:border-destructive"
      />
    </div>
  );
}
```

## Best Practices

### Usage Guidelines

- **Use appropriate row heights**: Set the `rows` attribute to provide adequate space for expected content length
- **Provide clear placeholders**: Use descriptive placeholder text that guides users on what to enter
- **Implement character limits**: For fields with length restrictions, provide visual feedback on character count
- **Handle resize behavior**: Use CSS classes to control textarea resizing (`resize-none`, `resize-y`, etc.)
- **Validate input appropriately**: Implement client-side validation for length, format, or content requirements
- **Use with form libraries**: Integrate with form libraries like React Hook Form for better state management and validation

### Accessibility

- **Label association**: Always associate textareas with labels using `htmlFor` and `id` attributes
- **Error messaging**: Use `aria-describedby` to link error messages and helper text to the textarea
- **Validation states**: Use `aria-invalid` to indicate validation errors for screen readers
- **Required fields**: Mark required textareas with the `required` attribute and provide clear visual indicators
- **Focus management**: Ensure textareas can be focused and navigated using keyboard navigation
- **Screen reader support**: Provide meaningful labels and descriptions for assistive technologies

### Performance

- **Controlled vs uncontrolled**: Use controlled components for form validation, uncontrolled for simple cases
- **Debounce input**: For expensive operations like auto-save, debounce the onChange handler
- **Optimize re-renders**: Use React.memo or useMemo for complex textarea implementations
- **Lazy loading**: For forms with many textareas, consider lazy loading or virtualization for large datasets

## Common Patterns

### Pattern 1: Form Integration with React Hook Form

```tsx
import { Textarea } from "@/components/ui/textarea";
import { useForm } from "react-hook-form";

interface FormData {
  message: string;
}

function FormExample() {
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<FormData>();

  const onSubmit = (data: FormData) => {
    console.log(data.message);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
      <div>
        <label htmlFor="message">Message</label>
        <Textarea
          id="message"
          {...register("message", {
            required: "Message is required",
            maxLength: { value: 500, message: "Message too long" },
          })}
          placeholder="Enter your message..."
          className={errors.message ? "border-destructive" : ""}
        />
        {errors.message && (
          <p className="text-sm text-destructive mt-1">
            {errors.message.message}
          </p>
        )}
      </div>
      <button type="submit">Submit</button>
    </form>
  );
}
```

### Pattern 2: Auto-growing Textarea

```tsx
import { Textarea } from "@/components/ui/textarea";
import { useRef, useEffect } from "react";

function AutoGrowTextarea() {
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  const handleInput = () => {
    const textarea = textareaRef.current;
    if (textarea) {
      textarea.style.height = "auto";
      textarea.style.height = `${textarea.scrollHeight}px`;
    }
  };

  return (
    <Textarea
      ref={textareaRef}
      onInput={handleInput}
      placeholder="This textarea grows as you type..."
      className="resize-none overflow-hidden min-h-16"
      rows={1}
    />
  );
}
```

### Pattern 3: Character Counter with Validation

```tsx
import { Textarea } from "@/components/ui/textarea";
import { useState } from "react";

function CharacterCounterTextarea() {
  const [content, setContent] = useState("");
  const maxLength = 280;
  const isOverLimit = content.length > maxLength;

  return (
    <div className="space-y-2">
      <Textarea
        value={content}
        onChange={(e) => setContent(e.target.value)}
        placeholder="Share your thoughts..."
        className={
          isOverLimit
            ? "border-destructive focus-visible:border-destructive"
            : ""
        }
      />
      <div className="flex justify-end">
        <span
          className={`text-sm ${isOverLimit ? "text-destructive" : "text-muted-foreground"}`}
        >
          {content.length}/{maxLength}
        </span>
      </div>
    </div>
  );
}
```
